<?php
// $Id$

/**
* @file
* Implements functions to grab media analytics for OERbit site
* Displays analytics on appropriate course or resource pages.
*/


/*
Portions of this module file are excerpted from the Google Analytics Counter Drupal module (http://drupal.org/project/google_analytics_counter), authored by @Vacilando (http://drupal.org/user/45996).

All code from the Google Analytics Counter module is licensed under the GNU General Public License (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html) and the reused and modified code is distributed here with those requirements.
Some modifications to the source code of the Google Analytics Counter module were made, and included in this OERbit Analytics module, by Jaclyn Cohen, 2013.03.29 - 2013.04.02.

This module is primarily authored by Jaclyn Cohen, with input from Kevin Coffman, Kathleen Omollo, Pieter Kleymeer and Dave Malicke.
[LICENSE/ATTR INFO]
*/


/** Helper Functions **/

function today() {
	$today = getdate();
	$mon = $today["mon"];
	$day = $today["mday"];
	$yr = $today["year"];
	if ($mon < 10) {
		$mon = "0".$mon;
	}
	if ($day < 10) {
		$day = "0".$day;
	}
	$curr_date = $yr."-".$mon."-".$day;
	return $curr_date;
} 


// for getting youtube video data RESTfully (TODO: update)
function get_value_fragile($id_string, $xml_string)
{
	$amt = strlen($id_string);
	$place = strpos($xml_string, $id_string);
	$matches = array();
	preg_match('%\d+%', substr($xml_string, $place+$amt), $matches);
	return $matches[0];
}

// Database table UPDATES TODO ASAP
// sub-cron distinctions TODO !


/* Google Analytics Counter pieces */
function oer_analytics_counter_construct_content($sumarray) {

  $result = '';

  $sum_of_pageviews = '';
  #$sum_of_pageviews .= '<span style="font-size:large;"';
  #$sum_of_pageviews .= ' title="';
  // If debugger is on, and if the user has admin rights for Google Analytics Counter.
  if (user_access('administer google analytics counter')) {
    $debuggeron = GOOGLE_ANALYTICS_COUNTER_DEBUG;
    if ($debuggeron == 1) {
      $titlemsg = $sumarray[3];
    }
  }
  #$sum_of_pageviews .= $titlemsg;
  #$sum_of_pageviews .= '">';

  $sum_of_pageviews .= $sumarray[0];
  #$sum_of_pageviews .= '</span>';
  //$countdays = $sumarray[1];
  //$cachedago = time()-$sumarray[2];

  if ($sumarray[0] == 0 AND $debuggeron <> 1) {
    // If $sumarray[2] is zero, it means nothing was fetched (cache expired but there was concurrency and new data could not be retrieved). We will return nothing -- until new value can be retrieved.
    //$result = '***'.$countdays.'***';
    $result = '';
  } else {
    $result .= $sum_of_pageviews;

    // If debugger is on, and if the user has admin rights for Google Analytics Counter.
    if (user_access('administer google analytics counter')) {
      if ($debuggeron == 1) {
        $result .= '<br/><font color="teal">' . $titlemsg . '</font>';
      }
    }
  }

  return $result;
}

function oer_analytics_counter_gac_get_count() {

  $path = oer_analytics_counter_get_searched_path();
  // This gives the AJAX call URI, e.g. /google_analytics_counter/gac_get_count/node/264455. We need to get the calling page's URI.
  $path = explode("gac_get_count", $path);
  $path = $path[1];
  // We have something like /node/264455. Remove the leading slash.
  $path = trim(substr($path, 1));
  $dls_path = "{$path}/zip_download";
  $sumarray = oer_analytics_counter_get_sum_per_path($path);
  $sumarray_dls = oer_analytics_counter_get_sum_per_path($dls_path);

  /**
   * Show manner of retrieval in debug.
   */
  if (GOOGLE_ANALYTICS_COUNTER_DEBUG == 1) {
    if (!empty($sumarray)) {
      $sumarray[3] .= " Data retrieved using AJAX.";
    }
  }

  // Return Data
  $json = array();
  if (!empty($sumarray)) {
    $json['#google-analytics-counter-' . md5($path)] = oer_analytics_counter_construct_content($sumarray); # . ' (AJAX)';
    //$json['#google-analytics-counter'] = oer_analytics_counter_construct_content($sumarray);
    $json['#google-analytics-counter-' . md5($dls_path)] = oer_analytics_counter_construct_content($sumarray_dls); # . ' (AJAX)';
  } else {
    $json['#google-analytics-counter-' . md5($path)] = NULL;
    //$json['#google-analytics-counter'] = NULL;
  }

  // Send JSON Back
  drupal_json($json);
  exit;
  #return mt_rand(0,1000000);
} // needed? perhaps useful

function oer_analytics_counter_get_searched_path() {
  $path = check_plain(implode('/', arg()));
  return $path;
} // TODO check integration (fine for now)

// fxn needs cleanup badly !! TODO
function oer_analytics_counter_get_sum_per_path($path) {

  $timenow = time();

  // Recognize special path 'all'
  if ($path == 'all') {
    // Let's use a less common path (this is for GA API)
    // Requires GA API to adopt http://drupal.org/node/949986
    $path = 'ga_api_all_paths';
  }

  // Watch out for http://code.google.com/apis/analytics/docs/gdata/gdataDeveloperGuide.html#quota
  //$cache_period = 60*60*24;
  $cache_period = round(variable_get('google_analytics_counter_api_refresh', 6) * 3600);
  //$cache_period = 90;
  // Needing to stay under the Google Analytics API quota, let's count how many API retrievals were made in the last 24 hours. We should take into consideration that the quota is reset at midnight PST (while time() always returns UTC) - that could be looked into one day.
  $dayquota = variable_get('google_analytics_counter_dayquota', array(0, 0));
  if ($timenow - $dayquota[0] >= 86400) {
    // If last API request was more than a day ago, set monitoring time to now.
    $dayquota[0] = $timenow;
    $dayquota[1] = 0;
    variable_set('google_analytics_counter_dayquota', array($dayquota[0], 0));
  }
  $apirequestallowed = FALSE;
  $maxdailyrequests = variable_get('google_analytics_counter_api_dayquota', 10000); // see http://code.google.com/apis/analytics/docs/gdata/gdataDeveloperGuide.html#quota
  if ($dayquota[1] <= $maxdailyrequests) {
    $apirequestallowed = TRUE;
  }

  $key = 'google_analytics_counter_' . $path;

  // Cache expiration logic is not governed by Drupal's cache_set. Cache life is set to much longer time than what the desired refresh time is so that in case of not receiving fresh value (for whatever reason) there is at least an approximate value available for display.
  // First let's find out when this cache entry was created.
  $cache = cache_get($key);
  $cachecreated = @$cache->created;
  $needfreshvalue = FALSE;
  if ((time() - $cachecreated) > $cache_period) {
    $needfreshvalue = TRUE;
  }

  // Let's say we only allow retrieval from Google Analytics API once a second. We have to watch the quotas - see http://code.google.com/apis/analytics/docs/gdata/gdataDeveloperGuide.html#quota
  $noconcurrency = FALSE;
  // $concurrencymax = 1 means that the difference of current and recorded time must be at least 1 second, which is all right. Should not need to be higher, except maybe for testing.
  $concurrencymax = variable_get('google_analytics_counter_concurrency', 1);
  if (($timenow - variable_get('google_analytics_counter_latest', ($timenow - $concurrencymax)) >= $concurrencymax)) { // If the value is not yet there (first run!), use ($timenow-$concurrencymax) otherwise it will always detect concurrency!
    $noconcurrency = TRUE;
  }
  $cachedvalue = '';
  // Get from cache if not expired, if we don't need a fresh value, if there is concurrency, or if we exceeded Google's day quota.
  if (($cache = cache_get($key) AND !empty($cache->data)) AND ((!$needfreshvalue OR !$noconcurrency OR !$apirequestallowed))) {
    $result = $cache->data;
    $cachedvalue = t(' This value was fetched from Drupal cache.');
  } else {

    // Let's set a time variable indicating no other script should retrieve Google Analytics data within some period.
    variable_set('google_analytics_counter_latest', $timenow);

    // Let's increase the count of API requests in order to check for daily quota excess.
    variable_set('google_analytics_counter_dayquota', array($dayquota[0], ($dayquota[1] + 1)));

    $request = array(
        'dimensions' => array('ga:date'), // date would not be necessary for totals, but if we calculate stats of views per day, we need it
        'metrics' => array('ga:pageviews'),
            //'#start_date' => strtotime('2005-01-01'), // We want to retrieve all page views for this path. The earliest valid start-date for Google Analytics is 2005-01-01.
    );
    $rows = _oer_analytics_counter_path_report($request, $path);

    $sum_of_pageviews = 0;
    $countdays = 0;
    $lookingforfirsthit = TRUE;
    foreach ($rows as $date) {
      // In case some error message appears, set zero and get out.
      if (!is_numeric($date['pageviews'])) {
        $sum_of_pageviews = 0;
        break;
      }
      $sum_of_pageviews += $date['pageviews'];
      // We need to count only days since when the first hit was registered
      if ($date['pageviews'] <> 0 OR !$lookingforfirsthit) {
        $countdays++;
        $lookingforfirsthit = FALSE;
      }
    }

    // Storing the count, days of counting, and also the absolute time of caching as well.
    $result = array($sum_of_pageviews, $countdays, $timenow);
    // Set the cache duration for much longer than the desired refresh period so as to assure approximate values are returned in case GA API limits are reached or if there are temporary problems with retrieving fresh values (that would set the displayed value to 0!)
    $safe_margin_cache_time = $cache_period * 50;
    cache_set($key, $result, 'cache', $safe_margin_cache_time);
    // All right. Now - if it's desired and if it's a node page - update Drupal's own page view counter
    if (variable_get('google_analytics_counter_update_node_counter', 0) == 1) {

      // Let's get the nid
      $nid = FALSE;
      $pathbits = explode('/', $path);
      if (($pathbits[0] == 'node') && is_numeric($pathbits[1])) {
        // Provided in format node/x
        $nid = $pathbits[1];
      } else {
        $pathbits = drupal_lookup_path('source', $path);
        $pathbits = explode('/', $pathbits);
        if (($pathbits[0] == 'node') && is_numeric($pathbits[1])) {
          // Provided as an alias
          $nid = $pathbits[1];
        }
      }

      if ($nid !== FALSE AND $sum_of_pageviews <> 0) {
        // This is a node, so update the node's counters.
        // We don't do anything with daycount here
        db_query('UPDATE {node_counter} SET daycount = 0, totalcount = %d, timestamp = %d WHERE nid = %d', $sum_of_pageviews, time(), $nid);
        // If we affected 0 rows, this is the first time viewing the node.
        if (!db_affected_rows()) {
          // We must create a new row to store counters for the new node.
          db_query('INSERT INTO {node_counter} (nid, daycount, totalcount, timestamp) VALUES (%d, 0, %d, %d)', $nid, $sum_of_pageviews, time());
        }
      }
    }
  }

  $lastfresh = $timenow - $result[2];
  $extrapolated_for_current_cache_period = 'N/A';
  // No reason to extrapolate if no data has been ever recorded (not a single date).
  if ($result[1] <> 0) {
    $views_per_second = $result[0] / ($result[1] * 60 * 60 * 24);
    $extrapolated_for_current_cache_period = $lastfresh * $views_per_second;

    // If extrapolation is desired, add it to the retrieved count.
    $addextrapolated = 0;
    if (variable_get('google_analytics_counter_extrapolation', 1) == 1) {
      $addextrapolated = round($extrapolated_for_current_cache_period);
      $result[0] += $addextrapolated;
    }
  }
  //// For debug information, see prior commit.
   return $result;
} // end google_analytics_counter_get_sum_per_path

function oer_analytics_counter_display($path='') {

  if ($path == '') {
    $path = oer_analytics_counter_get_searched_path();
    $dls_path = "{$path}/zip_download";
  }

  $refreshinseconds = variable_get('google_analytics_counter_ajax_refresh', '');
  if (!is_numeric($refreshinseconds))
    $refreshinseconds = 0;
  $msec = $refreshinseconds * 1000;

  $sumarray = oer_analytics_counter_get_sum_per_path($path);
  $sumarray_dls = oer_analytics_counter_get_sum_per_path($dls_path);
  $course_views = oer_analytics_counter_construct_content($sumarray);
  // see prior commit -- potential of adding to $block_content, but unlikely at curr. juncture (?)
  if (oer_analytics_counter_construct_content($sumarray_dls) > 5) {
    #$block_content .= '<br /><b>Total Materials Downloads:</b> '; // e.g. (see above comment)
    $course_dls = oer_analytics_counter_construct_content($sumarray_dls);
    return array("<b>Total Course Views:</b> {$course_views}", "<b>Total Bulk Downloads:</b> {$course_dls}");
  } else {
  	return array("<b>Total Course Views:</b> {$course_views}");
  }
  // js removed for now; unnecessary  
}


/** functions to get YouTube info (including making API calls) **/
// TODO refactoring

/* get (correct, aliased) page path from an OERbit node number */
function get_pagepath($nodenum) {
	$from_db = db_query("SELECT dst FROM {url_alias} WHERE src LIKE 'node/{$nodenum}'");
	while ($paths = db_fetch_object($from_db)) {
		$p = $paths->dst;
	}
	return $p;
} // TODO may need improved error checking


/* get stats by video (given video id and stat desired) */
function get_video_data($videoid, $param) // expects one of: 'views', 'comments', 'favs' as param, (in future incl: 'likes', or 'shares')
{
	$baseurl = "https://gdata.youtube.com/feeds/api/videos/".$videoid."?v=2";
	$result = drupal_http_request($baseurl);
	$res = $result->data;
	$dom = new DOMDocument;
	$dom->loadXML($res); 
	$result_str = $dom->saveXML();

	$xml_str = simplexml_load_string($result_str);
	$title = $xml_str->title;

	// somewhat fragile -- but given v2 API response robust, and easily adjustable for diff vals
	// v3 API in future.
	if ($param == 'views') {
		return get_value_fragile("viewCount=", $result_str);
	}
	if ($param == 'comments') {
		return get_value_fragile("countHint=", $result_str);
	}
	if ($param == 'favs') {
		return get_value_fragile("favoriteCount=", $result_str); // don't display these in phase1 of Analytics Project
	}
	return "ERROR"; // if it gets past the others - tmpry control in case of programmer forgetting
}


/********* HOOK METHODS *********/


/**
* Implements hook_cron().
*/

// TODO sub_functions, elysia_cron...
// TODO clean up and integrate queries

function oer_analytics_cron() {

	// non-API call population of vids table
	$vid_db_info = db_query("SELECT field_course_reference_nid, field_video_value FROM {content_field_video} INNER JOIN {content_field_course_reference} WHERE content_field_video.nid = content_field_course_reference.nid AND content_field_video.field_video_provider='youtube' GROUP BY content_field_video.field_video_value"); 

	$vid_items = array();
	while ($row = db_fetch_object($vid_db_info)) {
		$v_id = $row->field_video_value;
		if (strpos($v_id, "PLAYLIST") === FALSE) {
			$vid_items[$v_id] = array($row->field_course_reference_nid, get_video_data($v_id, "views"), get_video_data($v_id, "comments"));
		}
	}

	$assoc_courses = array();
	foreach($vid_items as $vid => $cnid) { // Y
		//drupal_set_message("Adding stuff to YT table");
		//$assoc_courses[$cnid[0]] = array();
		$assoc_courses[$cnid[0]] = array('views'=>0,'comments'=>0); // just set up associative arr
		drupal_set_message($cnid[0]."-".$cnid[1]."-".$cnid[2]);
		db_query("INSERT INTO {oer_analytics_vids} (videoid, course_nid, totalviews, totalcomments) VALUES ('{$vid}', {$cnid[0]}, {$cnid[1]}, {$cnid[2]})"); 
	} 


	// (TODO) for now, extracting from populated vids table because it's not broken from before
	// populating youtube table
	$extr_vids = db_query("SELECT course_nid, totalviews, totalcomments FROM {oer_analytics_vids}");
	$yt_info = array();
	while ($row = db_fetch_object($extr_vids)) {
		$c_ref = $row->course_nid;
		$yt_info[$c_ref] = array($row->totalviews, $row->totalcomments);
	}


	// foreach($vid_items as $vid => $cnid) {
	// 	//db_query("INSERT INTO {oer_analytics_youtube} (course_nid, totalviews, totalcomments) VALUES ({$cnid}, {$vals[0]}, {$vals[1]})");
	// 	$assoc_courses[$cnid[0]]["views"] += $cnid[1];
	// 	$assoc_courses[$cnid[0]]["comments"] += $cnid[2];
	// }

	foreach($yt_info as $cref => $vals) {
		$assoc_courses[$cref]["views"] += (int) $vals[0];
		drupal_set_message("current views for {$cref} is: {$assoc_courses[$cref]['views']}");
		$assoc_courses[$cref]["comments"] += (int) $vals[1];
		drupal_set_message("current comments for ${cref} is: {$assoc_courses[$cref]['comments']}");
	}

	foreach($assoc_courses as $cnid => $vals) {
		db_query("INSERT INTO {oer_analytics_youtube} (course_nid, totalviews, totalcomments) VALUES ({$cnid}, {$vals["views"]}, {$vals["comments"]})");
	}


	//// populating courses table (more later? see Google_Analytics_Counter module)
	//// commented out b/c for now, no need
	// $course_db_nids = db_query("SELECT nid FROM {content_type_course} GROUP BY content_type_course.nid"); // should be all course nids

	// $course_items = array();
	// while ($row = db_fetch_object($course_db_nids)) {
	// 	$c_nid = $row->nid;
	// 	array_push($course_items, $c_nid); // tmp: just creating an array of course nids (extra work, but to be sure)
	// }

	// foreach($course_items as $nid) {
	// 	db_query("INSERT INTO {oer_analytics_courses} (nid) VALUES ({$nid})");
	// }
	
}





/**
* Implementation of hook_block().
*/
function oer_analytics_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks['oer-analytics'] = array(
        'info' => t('Course Analytics'),
        'cache' => BLOCK_CACHE_PER_PAGE, // remember day cached, for speeding things up
      );
      return $blocks;
    case 'view':
      if (arg(0) == 'node' && is_numeric(arg(1))) { // node_load() -- check node type..
        return _oer_analytics_block(arg(1)); // gets info that will be displayed
      }
  }
} 

function _oer_analytics_block($nid) {
	$node = node_load($nid);
	if ($node->type == 'course') { // given context, unecessary check? Perhaps not.
		$stats = array();
		$full_stats = array();
		$vidcount = array();
		//$db_res = db_query("SELECT oer_analytics_courses.totalviews, oer_analytics_courses.total_zipdownloads, oer_analytics_youtube.totalviews, oer_analytics_youtube.totalcomments FROM {oer_analytics_courses} OUTER JOIN {oer_analytics_youtube} WHERE oer_analytics_youtube.course_nid = {$nid} or oer_analytics_courses.nid = {$nid}");

		//tmp -- these should really all be consolidated -- but just for now
		$db_res = db_query("SELECT course_nid, totalviews, totalcomments FROM {oer_analytics_youtube} WHERE course_nid = {$nid}");

		//$db_ga_res = db_query("SELECT nid, totalviews, total_zipdownloads FROM {oer_analytics_courses} WHERE nid = {$nid}");

		$db_res_vids = db_query("SELECT videoid FROM {oer_analytics_vids} WHERE course_nid={$nid}");

		$num_rows = $db_res_vids->num_rows;

		// similarly, these should all be consolidated.

		// while ($row = db_fetch_object($db_res_vids)) {
		// 	array_push($vidcount, "i");
		// }

		while ($row = db_fetch_object($db_res)) {
			//$yt_view = $row->oer_analytics_courses.totalviews;
			$yt_views = $row->totalviews;
			$yt_comm = $row->totalcomments;
			$stats[$row->course_nid] = array($yt_views, $yt_comm);
		}

		while ($row = db_fetch_object($db_ga_res)) {
			$courseviews = $row->totalviews;
			$dls = $row->total_zipdownloads;
			$gastats[$row->nid] = array($courseviews, $dls);
		}

		foreach($stats as $num=>$arr) {
			array_push($full_stats, "<b>Aggregate Youtube Views:</b> {$arr[0]}");
			array_push($full_stats, "<b>Aggregate Youtube Comments:</b> {$arr[1]}");
			array_push($full_stats, "<b>Youtube Vids in Course:</b> {$num_rows}");
		}

		$ga_stats = oer_analytics_counter_display();

		// fill in more later
		if (!empty($full_stats)) {
			return array(
				'subject' => t('Course Analytics'),
				//'content' => theme_item_list(array_merge($full_ga, $full_stats))
				'content' => theme_item_list(array_merge($ga_stats, $full_stats))
			);
		} else {
			return;
		}
	}
}


