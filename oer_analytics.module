<?php
// $Id$

/**
* @file
* Implements functions to grab Google and YouTube analytics for OERbit site
* Displays analytics on appropriate course or resource pages.
*/

include 'gapi.class.php';

/** Helper Functions **/

function today() {
	$today = getdate();
	$mon = $today["mon"];
	$day = $today["mday"];
	$yr = $today["year"];
	if ($mon < 10) {
		$mon = "0".$mon;
	}
	if ($day < 10) {
		$day = "0".$day;
	}
	$curr_date = $yr."-".$mon."-".$day;
	return $curr_date;
} // set time zone later to stop warnings


// for getting youtube video data RESTfully (TODO: update)
function get_value_fragile($id_string, $xml_string)
{
	$amt = strlen($id_string);
	$place = strpos($xml_string, $id_string);
	$matches = array();
	preg_match('%\d+%', substr($xml_string, $place+$amt), $matches);
	return $matches[0];
}

function check_for_updates($table_name) {
	// TODO - not here though, see book
}

function update_tables() {
	// TODO

	// see "check_for_updates" comment notes
}

/** functions to make API calls/get info **/


// GOOGLE ANALYTICS


// FUNCTION to get total course-materials-page views, given material page id (? not as important, TODO later)



// code below needs refactoring

/* FUNCTION to get (correct, aliased) page path from an OERbit node number */
function get_pagepath($nodenum) {
	$from_db = db_query("SELECT dst FROM {url_alias} WHERE src LIKE 'node/{$nodenum}'");
	while ($paths = db_fetch_object($from_db)) {
		$p = $paths->dst;
	}
	return $p; // hopefully -- there's always 1 as appropriate and this works
} // does this need better error checking? probably yes


/* FUNCTION to get total page views, given page path */
// refactoring to remove repeated code TODO, separate for easier testing atm
function get_google_views($page_path) {
	
	$profileid = 8335957;
	$today = today();
	$spec_filter = "pagePath={$page_path}"; // = instead of =~, let's see how that works for rate limits
	$ga->requestReportData($profileid,'pagePath','pageviews','-pageviews',$spec_filter,'2010-03-01',$today);
	$resparr = $ga->getResults();
	//$title = $resparr[0]->getPageTitle();
	foreach($resparr as $result) {
		$totalviews += $result->getPageviews();
	}
	return $totalviews;
}

/* FUNCTION to get total page visits, given page path */
function get_google_visits($page_path) {

	$profileid = 8335957;
	$today = today();
	$spec_filter = "pagePath={$page_path}"; // = instead of =~, let's see how that works for rate limits
	$ga->requestReportData($profileid,array('pagePath','pageTitle'), array('visits'),'-visits',$spec_filter,'2010-03-01',$today);
	$resparr = $ga->getResults();
	//$title = $resparr[0]->getPageTitle();
	foreach($resparr as $result) {
		$totalvisits += $result->getVisits();
	}
	return $totalvisits;
}

/* FUNCTION to get total (presumed) zip downloads, given node-id */
// aka times people clicked on the zip download link

function get_zip_downloads($node_num) { // assumes a course node id

	$profileid = 8335957;
	$today = today();
	$spec_filter = "pagePath=node/{$node_num}/zip_download"; // = instead of =~, let's see how that works for rate limits
	$ga->requestReportData($profileid, array('pagePath'), array('pageviews'),'-pageviews',$spec_filter,'2010-03-01',$today);
	$resparr = $ga->getResults();
	foreach($resparr as $result) {
		$dl_clicks += $result->getPageviews();
	}
	return $dl_clicks;
}


// YOUTUBE 

// FUNCTION to get stats by video (given video id and stat desired)
function get_video_data($videoid, $param) // expects one of: 'views', 'comments', 'favs' as param, (in future incl: 'likes', or 'shares')
{
	$baseurl = "https://gdata.youtube.com/feeds/api/videos/".$videoid."?v=2";
	//$res = file_get_contents($baseurl); // Bad Request happens here at least in one case ! TODO right away
// getting a 403 Forbidden, e.g. for:
	// https://gdata.youtube.com/feeds/api/videos/C2nNLavsTYw?v=2
// unlikely a problem with the fxn itself as this error did not occur in any Views cases

	// problem apparently solved by switching to drupal_http_request and ->data of result, hooray! n.b.
	$result = drupal_http_request($baseurl);
	$res = $result->data;
	$dom = new DOMDocument;
	$dom->loadXML($res); 
	$result_str = $dom->saveXML();

	$xml_str = simplexml_load_string($result_str); // errors here and surrounding result from BR-> $res is empty in ln115 (comments? test output with others where infrastructure exists)
	$title = $xml_str->title;

	// fragile and silly, but as ~placeholder -- easily adjustable for diff vals
	if ($param == 'views') {
		return get_value_fragile("viewCount=", $result_str);
	}
	if ($param == 'comments') {
		return get_value_fragile("countHint=", $result_str);
	}
	if ($param == 'favs') {
		return get_value_fragile("favoriteCount=", $result_str); // but don't display these in phase1
	}
	return "ERROR"; // if it gets past all the others - tmpry control
}


/********* HOOK METHODS *********/


/**
* Implements hook_cron().
*/

// may need to implement sub-functions so as to not do a ton of db calling each time, update daily or w/e

function oer_analytics_cron() {
	
	// queries should be from tables in original oerpublish db

	
	// POPULATE NEW TABLES

	// non-API call population of vids table
	$vid_db_info = db_query("SELECT field_course_reference_nid, field_video_value FROM {content_field_video} INNER JOIN {content_field_course_reference} WHERE content_field_video.nid = content_field_course_reference.nid AND content_field_video.field_video_provider='youtube' GROUP BY content_field_video.field_video_value"); 

	$vid_items = array();
	while ($row = db_fetch_object($vid_db_info)) {
		$v_id = $row->field_video_value;
		if (strpos($v_id, "PLAYLIST") === FALSE) {
			$vid_items[$v_id] = array($row->field_course_reference_nid, get_video_data($v_id, "views"), get_video_data($v_id, "comments"));
		}
	}
	// foreach($vid_items as $vid => $cnid) {
	// 	drupal_set_message((st($vid." : ".$cnid)));
	// }

	// actually inserting into table
// [[ this works! and it won't let us add duplicate entries (but need to make sure it won't for every cron -- no red errors ) ]]

	$assoc_courses = array();
	foreach($vid_items as $vid => $cnid) { // Y
		//drupal_set_message("Adding stuff to YT table");
		//$assoc_courses[$cnid[0]] = array();
		$assoc_courses[$cnid[0]] = array('views'=>0,'comments'=>0); // just set up associative arr
		drupal_set_message($cnid[0]."-".$cnid[1]."-".$cnid[2]);
		db_query("INSERT INTO {oer_analytics_vids} (videoid, course_nid, totalviews, totalcomments) VALUES ('{$vid}', {$cnid[0]}, {$cnid[1]}, {$cnid[2]})"); // Y -- works to populate vids table
		//db_query("INSERT INTO {oer_analytics_youtube} (course_nid, totalviews, totalcomments) VALUES (")

	} 

	// try at populating Youtube table right here

	// now extracting from populated vids table because it's not broken from before
	$extr_vids = db_query("SELECT course_nid, totalviews, totalcomments FROM {oer_analytics_vids} GROUP BY course_nid"); // will that aggregate in-query or no?
	$yt_info = array();
	while ($row = db_fetch_object($extr_vids)) {
		$c_ref = $row->course_nid;
		$yt_info[$c_ref] = array($row->totalviews, $row->totalcomments);
	}


	// foreach($vid_items as $vid => $cnid) {
	// 	//db_query("INSERT INTO {oer_analytics_youtube} (course_nid, totalviews, totalcomments) VALUES ({$cnid}, {$vals[0]}, {$vals[1]})");
	// 	$assoc_courses[$cnid[0]]["views"] += $cnid[1];
	// 	$assoc_courses[$cnid[0]]["comments"] += $cnid[2];
	// }

	foreach($yt_info as $cref => $vals) {
		$assoc_courses[$cref]["views"] += (int) $vals[0];
		drupal_set_message("current views for {$cref} is: {$assoc_courses[$cref]['views']}");
		$assoc_courses[$cref]["comments"] += (int) $vals[1];
		drupal_set_message("current comments for ${cref} is: {$assoc_courses[$cref]['comments']}");
	}

	foreach($assoc_courses as $cnid => $vals) {
		db_query("INSERT INTO {oer_analytics_youtube} (course_nid, totalviews, totalcomments) VALUES ({$cnid}, {$vals["views"]}, {$vals["comments"]})");
	} // seems to work finally, but in the table, e.g. for node 2062, numbers are wrong -- views say 1 when it should be 478, and comments say 1 when they should be 0. What's happening there?


	/***********/


	// non-api call population of courses table -- commented out because as stands it hits rate limits
	$course_db_nids = db_query("SELECT nid FROM {content_type_course}"); // should be all course nids

	// $course_items = array();
	// while ($row = db_fetch_object($course_db_nids)) {
	// 	$c_nid = $row->nid;
	// 	// get page path from db
	// 	$path = get_pagepath($c_nid);
	// 	drupal_set_message((st($path)));
	// 	$course_items[$c_nid] = array(get_google_views($path), get_google_visits($path), get_zip_downloads($c_nid));
	// }
	$course_items = array();
	while ($row = db_fetch_object($course_db_nids)) {
		$c_nid = $row->nid;
		array_push($course_items, $c_nid); // tmp: just creating an array of course nids (extra work but to be sure)
	}

	//foreach($course_items as $nid => $infos) {
	foreach($course_items as $nid) {
		//db_query("INSERT INTO {oer_analytics_courses} (nid, totalviews, totalvisits, total_zipdownloads) VALUES ({$c_nid}, {$infos[0]}, {$infos[1]}, {$infos[2]})");
		db_query("INSERT INTO {oer_analytics_courses} (nid) VALUES ({$nid}) GROUP BY nid");
	}


	// get dynamic information as well





// populate the Youtube table from the vids and courses tables... (need only the youtube table really? all w/ the same course ref nid, etc?)










/********************************** */



	// do population of oer_analytics_youtube table
	// TODO

	// // create arrays for oer_analytics_courses entries
	// $course_info = db_query('SELECT nid, dst FROM {content_type_course} INNER JOIN {url_alias} WHERE COALESCE("node/",content_type_course.nid) = url_alias.src'); // doesn't work in phpMyAdmin..



	// // do population of oer_analytics_courses table
	// // TODO
	


	// // do population of oer_analytics_youtube table

	// # this query (and ~therefore ensuing code) assumes successful population of other two databases
	// $youtube_aggr_info = db_query('SELECT course_nid, oer_analytics_vids.totalviews, totalcomments FROM {oer_analytics_vids} INNER JOIN {oer_analytics_courses} WHERE oer_analytics_vids.course_nid = oer_analytics_courses.nid'); // totalviews can be ambig query




	// originally this should only be performed once and updated as we go
	// so need a different fxn to check for updates and (another?) to update this


// // this works! and it won't let us add duplicate entries (but need to make sure it won't for every cron -- no red errors )

// 	foreach($vid_entries as $entry) {
// 		foreach($entry as $k=>$e) {
// 			drupal_set_message("Adding course id to YT table");
// 			db_query("INSERT INTO {oer_analytics_youtube} (course_nid) VALUES ($e)"); //?
// 		}

// 	}
	
	
}





/**
* Implementation of hook_block().
*/
function oer_analytics_block($op = 'list', $delta = 0, $edit = array()) {
	switch($op) {
		case 'list':

	}

}



